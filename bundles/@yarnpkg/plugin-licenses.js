/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-licenses",
factory: function (require) {
var plugin=(()=>{var ae=Object.create,S=Object.defineProperty;var ce=Object.getOwnPropertyDescriptor;var le=Object.getOwnPropertyNames,_=Object.getOwnPropertySymbols,pe=Object.getPrototypeOf,V=Object.prototype.hasOwnProperty,de=Object.prototype.propertyIsEnumerable;var z=(e,t,n)=>t in e?S(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,E=(e,t)=>{for(var n in t||(t={}))V.call(t,n)&&z(e,n,t[n]);if(_)for(var n of _(t))de.call(t,n)&&z(e,n,t[n]);return e};var fe=e=>S(e,"__esModule",{value:!0});var d=e=>{if(typeof require!="undefined")return require(e);throw new Error('Dynamic require of "'+e+'" is not supported')};var D=(e,t)=>{for(var n in t)S(e,n,{get:t[n],enumerable:!0})},ue=(e,t,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of le(t))!V.call(e,i)&&i!=="default"&&S(e,i,{get:()=>t[i],enumerable:!(n=ce(t,i))||n.enumerable});return e},f=e=>ue(fe(S(e!=null?ae(pe(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var Le={};D(Le,{default:()=>xe});var ne=f(d("@yarnpkg/cli")),L=f(d("@yarnpkg/core")),v=f(d("clipanion"));var s=f(d("@yarnpkg/core")),m=f(d("@yarnpkg/fslib"));var W={};D(W,{fs:()=>he,getPackagePath:()=>me});var K=f(d("@yarnpkg/plugin-pnp")),A=f(d("@yarnpkg/core")),j=f(d("@yarnpkg/fslib")),J=f(d("@yarnpkg/libzip")),me=async(e,t)=>{ge(e);let n=A.structUtils.convertPackageToLocator(t),i={name:A.structUtils.stringifyIdent(n),reference:n.reference},r=$.getPackageInformation(i);if(!r)return null;let{packageLocation:o}=r;return o},$,ge=e=>{$||($=module.require((0,K.getPnpPath)(e).cjs))},he=new j.VirtualFS({baseFs:new j.ZipOpenFS({libzip:(0,J.getLibzipSync)(),readOnlyArchives:!0})});var B={};D(B,{_getYarnStateAliases:()=>G,fs:()=>ye,getPackagePath:()=>Pe});var x=f(d("@yarnpkg/core")),q=f(d("@yarnpkg/parsers")),w=f(d("@yarnpkg/fslib")),Pe=async(e,t)=>{await ke(e);let n=x.structUtils.convertPackageToLocator(t),i=x.structUtils.stringifyLocator(n),r=F[i]||Z[i];if(!r)return null;let o=r.locations[0];return o?w.ppath.join(e.cwd,o):e.cwd},F,Z,ke=async e=>{if(!F){let t=w.ppath.join(e.configuration.projectCwd,w.Filename.nodeModules,".yarn-state.yml");F=(0,q.parseSyml)(await w.xfs.readFilePromise(t,"utf8")),Z=G(F)}},ye=w.xfs,G=e=>Object.entries(e).reduce((t,[n,i])=>{if(!i.aliases)return t;let r=x.structUtils.parseLocator(n);for(let o of i.aliases){let c=x.structUtils.makeLocator(r,o),h=x.structUtils.stringifyLocator(c);t[h]=i}return t},{});var H=e=>{switch(e){case"pnp":return W;case"node-modules":return B;default:throw new Error("Unsupported linker")}};var $e=m.npath.basename(__dirname)==="@yarnpkg"?m.ppath.join(m.npath.toPortablePath(__dirname),"../.."):m.ppath.join(m.npath.toPortablePath(__dirname),".."),Q=async(e,t,n,i,r)=>{let o={},c={children:o},h=await X(e,n,i),u=H(e.configuration.get("nodeLinker"));for(let[a,l]of h.entries()){let p=await u.getPackagePath(e,l);if(p===null)continue;let P=JSON.parse(await u.fs.readFilePromise(m.ppath.join(p,m.Filename.manifest),"utf8")),{license:g,url:N,vendorName:T,vendorUrl:I}=ve(P);o[g]||(o[g]={value:s.formatUtils.tuple(s.formatUtils.Type.NO_HINT,g),children:{}});let M=s.structUtils.convertPackageToLocator(l),k=s.formatUtils.tuple(s.formatUtils.Type.DEPENDENT,{locator:M,descriptor:a}),y=r?{}:E(E(E({},N?{url:{value:s.formatUtils.tuple(s.formatUtils.Type.NO_HINT,Y("URL",N,t))}}:{}),T?{vendorName:{value:s.formatUtils.tuple(s.formatUtils.Type.NO_HINT,Y("VendorName",T,t))}}:{}),I?{vendorUrl:{value:s.formatUtils.tuple(s.formatUtils.Type.NO_HINT,Y("VendorUrl",I,t))}}:{}),re={value:k,children:y},oe=s.structUtils.stringifyLocator(M),se=o[g].children;se[oe]=re}return c},X=async(e,t,n)=>{var u;let i=new Map,r,o=new Set(["api-server","cache"]);if(t){if(n){for(let l of e.workspaces)l.manifest.devDependencies.clear(),((u=l.manifest.name)==null?void 0:u.scope)==="flocon-trpg"&&o.delete(l.manifest.name.name)&&(l.manifest.dependencies.clear(),l.manifest.peerDependencies.clear());let a=await s.Cache.find(e.configuration);await e.resolveEverything({report:new s.ThrowReport,cache:a})}else throw new Error("--production=false is not supported.");r=e.storedDescriptors.values()}else throw new Error("--recursive=false is not supported.");if(o.size!==0)throw new Error("Following flocon-trpg packages are not found. Renamed or removed?: "+JSON.stringify([...o]));let c=s.miscUtils.sortMap(r,[a=>s.structUtils.stringifyIdent(a),a=>s.structUtils.isVirtualDescriptor(a)?"0":"1",a=>a.range]),h=new Set;for(let a of c.values()){let l=e.storedResolutions.get(a.descriptorHash);if(!l)continue;let p=e.storedPackages.get(l);if(!p||p.scope==="flocon-trpg"&&p.name==="servers")continue;let{descriptorHash:P}=s.structUtils.isVirtualDescriptor(a)?s.structUtils.devirtualizeDescriptor(a):a;h.has(P)||(h.add(P),i.set(a,p))}return i};function we(e){let t={},n=e.match(/^([^(<]+)/);if(n){let o=n[0].trim();o&&(t.name=o)}let i=e.match(/<([^>]+)>/);i&&(t.email=i[1]);let r=e.match(/\(([^)]+)\)/);return r&&(t.url=r[1]),t}var ve=e=>{let{license:t,licenses:n,repository:i,homepage:r,author:o}=e,c=typeof o=="string"?we(o):o;return{license:(()=>{if(t)return R(t);if(n){if(!Array.isArray(n))return R(n);if(n.length===1)return R(n[0]);if(n.length>1)return`(${n.map(R).join(" OR ")})`}return ee})(),url:(i==null?void 0:i.url)||r,vendorName:c==null?void 0:c.name,vendorUrl:r||(c==null?void 0:c.url)}},ee="UNKNOWN",R=e=>(typeof e!="string"?e.type:e)||ee,Y=(e,t,n)=>n?t:`${e}: ${t}`,te=async(e,t,n)=>{let i=await X(e,t,n),r=H(e.configuration.get("nodeLinker")),o=new Map;for(let h of i.values()){let u=await r.getPackagePath(e,h);if(u===null)continue;let a=JSON.parse(await r.fs.readFilePromise(m.ppath.join(u,m.Filename.manifest),"utf8")),p=(await r.fs.readdirPromise(u,{withFileTypes:!0})).filter(k=>k.isFile()).map(({name:k})=>k),P=p.find(k=>{let y=k.toLowerCase();return y==="license"||y.startsWith("license.")||y==="unlicense"||y.startsWith("unlicense.")});if(!P)continue;let g=await r.fs.readFilePromise(m.ppath.join(u,P),"utf8"),N=p.find(k=>{let y=k.toLowerCase();return y==="notice"||y.startsWith("notice.")}),T;N&&(T=await r.fs.readFilePromise(m.ppath.join(u,N),"utf8"));let I=T?`${g}

NOTICE

${T}`:g,M=o.get(I);M?M.set(a.name,a):o.set(I,new Map([[a.name,a]]))}let c=`THE FOLLOWING SETS FORTH ATTRIBUTION NOTICES FOR THIRD PARTY SOFTWARE THAT MAY BE CONTAINED IN PORTIONS OF FLOCON WEB SERVER PRODUCT.

`;for(let[h,u]of o.entries()){c+=`-----

`;let a=[],l=[];for(let{name:P,repository:g}of u.values())a.push(P),(g==null?void 0:g.url)&&l.push(u.size===1?g.url:`${g.url} (${P})`);let p=[];p.push(`The following software may be included in this product: ${a.join(", ")}.`),l.length>0&&p.push(`A copy of the source code may be downloaded from ${l.join(", ")}.`),p.push("This software contains the following license and notice below:"),c+=`${p.join(" ")}

`,c+=`${h.trim()}

`}return c};var O=class extends v.Command{constructor(){super(...arguments);this.recursive=v.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=v.Option.Boolean("--production",!1,{description:"Exclude development dependencies"});this.json=v.Option.Boolean("--json",!1,{description:"Format output as JSON"});this.excludeMetadata=v.Option.Boolean("--exclude-metadata",!1,{description:"Exclude dependency metadata from output"})}async execute(){let t=await L.Configuration.find(this.context.cwd,this.context.plugins),{project:n,workspace:i}=await L.Project.find(t,this.context.cwd);if(!i)throw new ne.WorkspaceRequiredError(n.cwd,this.context.cwd);await n.restoreInstallState();let r=await Q(n,this.json,this.recursive,this.production,this.excludeMetadata);L.treeUtils.emitTree(r,{configuration:t,stdout:this.context.stdout,json:this.json,separators:1})}};O.paths=[["licenses","list"]],O.usage=v.Command.Usage({description:"display the licenses for all packages in the project",details:`
      This command prints the license information for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the listing will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the listing will exclude development dependencies.
    `,examples:[["List all licenses of direct dependencies","$0 licenses list"],["List all licenses of direct and transitive dependencies","$0 licenses list --recursive"],["List all licenses of production dependencies only","$0 licenses list --production"]]});var ie=f(d("@yarnpkg/cli")),C=f(d("@yarnpkg/core")),b=f(d("clipanion"));var U=class extends b.Command{constructor(){super(...arguments);this.recursive=b.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=b.Option.Boolean("--production",!1,{description:"Exclude development dependencies"})}async execute(){let t=await C.Configuration.find(this.context.cwd,this.context.plugins),{project:n,workspace:i}=await C.Project.find(t,this.context.cwd);if(!i)throw new ie.WorkspaceRequiredError(n.cwd,this.context.cwd);await n.restoreInstallState();let r=await te(n,this.recursive,this.production);this.context.stdout.write(r)}};U.paths=[["licenses","generate-disclaimer"]],U.usage=b.Command.Usage({description:"display the license disclaimer including all packages in the project",details:`
      This command prints the license disclaimer for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the disclaimer will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the disclaimer will exclude development dependencies.
    `,examples:[["Include licenses of direct dependencies","$0 licenses generate-disclaimer"],["Include licenses of direct and transitive dependencies","$0 licenses generate-disclaimer --recursive"],["Include licenses of production dependencies only","$0 licenses list --production"]]});var Te={commands:[O,U]},xe=Te;return Le;})();
return plugin;
}
};

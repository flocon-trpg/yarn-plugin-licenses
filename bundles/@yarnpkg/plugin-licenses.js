/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-licenses",
factory: function (require) {
var plugin=(()=>{var ce=Object.create,U=Object.defineProperty;var le=Object.getOwnPropertyDescriptor;var de=Object.getOwnPropertyNames,B=Object.getOwnPropertySymbols,pe=Object.getPrototypeOf,z=Object.prototype.hasOwnProperty,fe=Object.prototype.propertyIsEnumerable;var K=(e,t,n)=>t in e?U(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,j=(e,t)=>{for(var n in t||(t={}))z.call(t,n)&&K(e,n,t[n]);if(B)for(var n of B(t))fe.call(t,n)&&K(e,n,t[n]);return e};var ue=e=>U(e,"__esModule",{value:!0});var d=e=>{if(typeof require!="undefined")return require(e);throw new Error('Dynamic require of "'+e+'" is not supported')};var $=(e,t)=>{for(var n in t)U(e,n,{get:t[n],enumerable:!0})},me=(e,t,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of de(t))!z.call(e,i)&&i!=="default"&&U(e,i,{get:()=>t[i],enumerable:!(n=le(t,i))||n.enumerable});return e},p=e=>me(ue(U(e!=null?ce(pe(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var be={};$(be,{default:()=>Le});var ie=p(d("@yarnpkg/cli")),b=p(d("@yarnpkg/core")),v=p(d("clipanion"));var a=p(d("@yarnpkg/core")),u=p(d("@yarnpkg/fslib"));var R={};$(R,{fs:()=>Pe,getPackagePath:()=>ge});var q=p(d("@yarnpkg/plugin-pnp")),A=p(d("@yarnpkg/core")),F=p(d("@yarnpkg/fslib")),J=p(d("@yarnpkg/libzip")),ge=async(e,t)=>{he(e);let n=A.structUtils.convertPackageToLocator(t),i={name:A.structUtils.stringifyIdent(n),reference:n.reference},r=W.getPackageInformation(i);if(!r)return null;let{packageLocation:s}=r;return s},W,he=e=>{W||(W=module.require((0,q.getPnpPath)(e).cjs))},Pe=new F.VirtualFS({baseFs:new F.ZipOpenFS({libzip:(0,J.getLibzipSync)(),readOnlyArchives:!0})});var H={};$(H,{_getYarnStateAliases:()=>G,fs:()=>we,getPackagePath:()=>ye});var L=p(d("@yarnpkg/core")),V=p(d("@yarnpkg/parsers")),w=p(d("@yarnpkg/fslib")),ye=async(e,t)=>{await ke(e);let n=L.structUtils.convertPackageToLocator(t),i=L.structUtils.stringifyLocator(n),r=E[i]||Z[i];if(!r)return null;let s=r.locations[0];return s?w.ppath.join(e.cwd,s):e.cwd},E,Z,ke=async e=>{if(!E){let t=w.ppath.join(e.configuration.projectCwd,w.Filename.nodeModules,".yarn-state.yml");E=(0,V.parseSyml)(await w.xfs.readFilePromise(t,"utf8")),Z=G(E)}},we=w.xfs,G=e=>Object.entries(e).reduce((t,[n,i])=>{if(!i.aliases)return t;let r=L.structUtils.parseLocator(n);for(let s of i.aliases){let l=L.structUtils.makeLocator(r,s),o=L.structUtils.stringifyLocator(l);t[o]=i}return t},{});var Y=e=>{switch(e){case"pnp":return R;case"node-modules":return H;default:throw new Error("Unsupported linker")}};var Re=u.npath.basename(__dirname)==="@yarnpkg"?u.ppath.join(u.npath.toPortablePath(__dirname),"../.."):u.ppath.join(u.npath.toPortablePath(__dirname),".."),Q=async(e,t,n,i,r)=>{let s={},l={children:s},o=await X(e,n,i),c=Y(e.configuration.get("nodeLinker"));for(let[f,m]of o.entries()){let g=await c.getPackagePath(e,m);if(g===null)continue;let T=JSON.parse(await c.fs.readFilePromise(u.ppath.join(g,u.Filename.manifest),"utf8")),{license:h,url:P,vendorName:x,vendorUrl:N}=Te(T);s[h]||(s[h]={value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,h),children:{}});let M=a.structUtils.convertPackageToLocator(m),y=a.formatUtils.tuple(a.formatUtils.Type.DEPENDENT,{locator:M,descriptor:f}),k=r?{}:j(j(j({},P?{url:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,_("URL",P,t))}}:{}),x?{vendorName:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,_("VendorName",x,t))}}:{}),N?{vendorUrl:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,_("VendorUrl",N,t))}}:{}),oe={value:y,children:k},se=a.structUtils.stringifyLocator(M),ae=s[h].children;ae[se]=oe}return l},X=async(e,t,n)=>{let i=new Map,r;if(t){if(n){for(let c of e.workspaces)c.manifest.devDependencies.clear();let o=await a.Cache.find(e.configuration);await e.resolveEverything({report:new a.ThrowReport,cache:o})}r=e.storedDescriptors.values()}else r=e.workspaces.flatMap(o=>{let c=[o.anchoredDescriptor];for(let[f,m]of o.dependencies.entries())n&&o.manifest.devDependencies.has(f)||c.push(m);return c});let s=a.miscUtils.sortMap(r,[o=>a.structUtils.stringifyIdent(o),o=>a.structUtils.isVirtualDescriptor(o)?"0":"1",o=>o.range]),l=new Set;for(let o of s.values()){let c=e.storedResolutions.get(o.descriptorHash);if(!c)continue;let f=e.storedPackages.get(c);if(!f)continue;let{descriptorHash:m}=a.structUtils.isVirtualDescriptor(o)?a.structUtils.devirtualizeDescriptor(o):o;l.has(m)||(l.add(m),i.set(o,f))}return i};function ve(e){let t={},n=e.match(/^([^(<]+)/);if(n){let s=n[0].trim();s&&(t.name=s)}let i=e.match(/<([^>]+)>/);i&&(t.email=i[1]);let r=e.match(/\(([^)]+)\)/);return r&&(t.url=r[1]),t}var Te=e=>{let{license:t,licenses:n,repository:i,homepage:r,author:s}=e,l=typeof s=="string"?ve(s):s;return{license:(()=>{if(t)return C(t);if(n){if(!Array.isArray(n))return C(n);if(n.length===1)return C(n[0]);if(n.length>1)return`(${n.map(C).join(" OR ")})`}return ee})(),url:te(i)||r,vendorName:l==null?void 0:l.name,vendorUrl:r||(l==null?void 0:l.url)}},ee="UNKNOWN",C=e=>(typeof e!="string"?e.type:e)||ee,te=e=>typeof e=="string"?e:e==null?void 0:e.url,_=(e,t,n)=>n?t:`${e}: ${t}`,ne=async(e,t,n)=>{let i=await X(e,t,n),r=Y(e.configuration.get("nodeLinker")),s=new Map;for(let o of i.values()){let c=await r.getPackagePath(e,o);if(c===null)continue;let f=JSON.parse(await r.fs.readFilePromise(u.ppath.join(c,u.Filename.manifest),"utf8")),g=(await r.fs.readdirPromise(c,{withFileTypes:!0})).filter(y=>y.isFile()).map(({name:y})=>y),T=g.find(y=>{let k=y.toLowerCase();return k==="license"||k.startsWith("license.")||k==="unlicense"||k.startsWith("unlicense.")});if(!T)continue;let h=await r.fs.readFilePromise(u.ppath.join(c,T),"utf8"),P=g.find(y=>{let k=y.toLowerCase();return k==="notice"||k.startsWith("notice.")}),x;P&&(x=await r.fs.readFilePromise(u.ppath.join(c,P),"utf8"));let N=x?`${h}

NOTICE

${x}`:h,M=s.get(N);M?M.set(f.name,f):s.set(N,new Map([[f.name,f]]))}let l=`THE FOLLOWING SETS FORTH ATTRIBUTION NOTICES FOR THIRD PARTY SOFTWARE THAT MAY BE CONTAINED IN PORTIONS OF THE ${String(e.topLevelWorkspace.manifest.raw.name).toUpperCase().replace(/-/g," ")} PRODUCT.

`;for(let[o,c]of s.entries()){l+=`-----

`;let f=[],m=[];for(let{name:T,repository:h}of c.values()){f.push(T);let P=te(h);P&&m.push(c.size===1?P:`${P} (${T})`)}let g=[];g.push(`The following software may be included in this product: ${f.join(", ")}.`),m.length>0&&g.push(`A copy of the source code may be downloaded from ${m.join(", ")}.`),g.push("This software contains the following license and notice below:"),l+=`${g.join(" ")}

`,l+=`${o.trim()}

`}return l};var S=class extends v.Command{constructor(){super(...arguments);this.recursive=v.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=v.Option.Boolean("--production",!1,{description:"Exclude development dependencies"});this.json=v.Option.Boolean("--json",!1,{description:"Format output as JSON"});this.excludeMetadata=v.Option.Boolean("--exclude-metadata",!1,{description:"Exclude dependency metadata from output"})}async execute(){let t=await b.Configuration.find(this.context.cwd,this.context.plugins),{project:n,workspace:i}=await b.Project.find(t,this.context.cwd);if(!i)throw new ie.WorkspaceRequiredError(n.cwd,this.context.cwd);await n.restoreInstallState();let r=await Q(n,this.json,this.recursive,this.production,this.excludeMetadata);b.treeUtils.emitTree(r,{configuration:t,stdout:this.context.stdout,json:this.json,separators:1})}};S.paths=[["licenses","list"]],S.usage=v.Command.Usage({description:"display the licenses for all packages in the project",details:`
      This command prints the license information for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the listing will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the listing will exclude development dependencies.
    `,examples:[["List all licenses of direct dependencies","$0 licenses list"],["List all licenses of direct and transitive dependencies","$0 licenses list --recursive"],["List all licenses of production dependencies only","$0 licenses list --production"]]});var re=p(d("@yarnpkg/cli")),D=p(d("@yarnpkg/core")),I=p(d("clipanion"));var O=class extends I.Command{constructor(){super(...arguments);this.recursive=I.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=I.Option.Boolean("--production",!1,{description:"Exclude development dependencies"})}async execute(){let t=await D.Configuration.find(this.context.cwd,this.context.plugins),{project:n,workspace:i}=await D.Project.find(t,this.context.cwd);if(!i)throw new re.WorkspaceRequiredError(n.cwd,this.context.cwd);await n.restoreInstallState();let r=await ne(n,this.recursive,this.production);this.context.stdout.write(r)}};O.paths=[["licenses","generate-disclaimer"]],O.usage=I.Command.Usage({description:"display the license disclaimer including all packages in the project",details:`
      This command prints the license disclaimer for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the disclaimer will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the disclaimer will exclude development dependencies.
    `,examples:[["Include licenses of direct dependencies","$0 licenses generate-disclaimer"],["Include licenses of direct and transitive dependencies","$0 licenses generate-disclaimer --recursive"],["Include licenses of production dependencies only","$0 licenses list --production"]]});var xe={commands:[S,O]},Le=xe;return be;})();
return plugin;
}
};
